### 1 HashMap
HashMap，顾名思义，是一种基于哈希函数实现的map，又被称为哈希表、散列表。它是基于快速存取的角度设计的，也是一种典型的空间换时间的做法。map表示一种一对一的映射关系，一个键对应一个值，键不可重复（重复的键只会存储最后一次的值）。它允许使用 null 值和 null 键。除了不同步和允许使用 null 之外，HashMap与Hashtable大致相同。该类是不能保证顺序的。由于使用哈希函数定位，所以它的存取非常高效。

- 基于数组、链表、红黑树和哈希函数实现。
- 允许使用null值和null键。
- 键值对是无序的，因为hash值随机。想要保证插入顺序可以使用LinkedHashMap。
- 除了不同步和允许使用 null 之外，HashMap与Hashtable大致相同。虽然Hashtable是同步的，但在多线程下建议使用ConcurrentHashMap替代。
- 因为使用哈希函数定位，存取的效率都很高，时间复杂度为O(1)。



### 2 1.7与1.8的区别
- 1）数据结构：
	+ 1.7 数组+链表。
	+ 1.8 数组+链表+红黑树。当链表长度达到8的时候，就会将链表转成红黑树。时间复杂度从O(N)变成O(logN)，效率提高。
- 2）添加元素：
	+ 1.7 头插法，当出现哈希冲突时，使用一条单链表存储冲突的元素，将最新的元素插入到链表头。头插法容易出现环形链表死循环的问题。
	+ 1.8 尾插法，可以解决死循环的问题。

### 3 get方法

查找流程：

1. 哈希表不为空的情况下，通过key的hash值定位到某个索引；
2. 如果该索引处存在头节点，判断key是否相等（先hashCode后equals）；
3. 如果该头节点是红黑树的根节点，则去红黑树中查找；
4. 以上情况没查到，则遍历该索引处整个链表，先比较key的hash值，若hash值相同，再用equals方法比较key。



### 4 put方法

添加流程：

1. 是否空表，空表则直接扩容；
2. 计算存储位置
   - 该位置无节点，则直接存放；
   - 该位置有节点，则根据是否是树节点，分别去链表和红黑树中查找key
     - key不存在，直接存放；
     - key已存在，根据参数onlyIfAbsent判断是否覆盖原值；

4. 添加方法属于结构性修改，递增modCount值；
5. 当实际存储键值对个数大于扩容阈值（++size > threshold），则调用扩容方法。



### 5 resize方法

扩容机制涉及到两个成员变量，扩容阈值`threshold`和负载因子`loadFactor`。扩容阈值的计算公式为`threshold = loadFactor * 当前容量`。我们不断地向HashMap中添加元素，当元素个数大于这个阈值，就会触发扩容。



扩容方法主要做了三件事：1、计算新容量和新临界值；2、基于新容量创建新数组；3、转移数据。首次put元素需要进行扩容为默认容量16，临界值16*0.75=12，以后扩容后的数组长度和临界值都变为原来的两倍。



### 6 值得一提的巧妙设计

#### 6.1 哈希函数

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

如上是JDK中哈希函数的实现。设计者为什么不直接使用key的hashCode作为hash值，而是又对其执行异或操作呢？

因为我们平时使用map的时候，存储键值对数量绝大多数都在 2^16 以内。定位时，使用的是`（n-1）& hash`，这个&运算，只有hash值的低16位（甚至更低）参与运算，如果两个key的hash只有高16位有变化，那么此时也会映射到同一索引，产生碰撞。

所以 `h >>> 16` 取到hashCode高16位，再与hashCode本身异或运算，可以得到更加随机的效果，达到了散列的目的。这里使用异或也是为了更加随机，如果使用 & 、| 都会令结果偏向0或1。



#### 6.2 定位使用 (n - 1) & hash

想要把一个数映射到一个给定的范围，通常可以采用除数取余的方式，假设数组长度为16，可以使用 hash % 16，结果在0 ~ 15 之间。这种方法虽然可以将哈希值映射到一个给定范围的确切位置，但不够高效。有一种更加高效的方式，位运算。也就是说 `(n - 1) & hash` 与`hash % n`是等价的，但这个等价有个前提，那就是n一定是2的整数次幂。可以表示为`hash % 2^n ⇔ hash & (2^n-1)`。



#### 6.3 容量一定是2的整数次幂

为了使用更加高效的定位方法`(n - 1) & hash`



#### 6.4 resize方法转移数据时对链表分组

在将元素从旧数组向新数组转移的过程中，对于旧数组中，存储在链表中的元素的转移方式与1.7有所不同，让我们看看设计者用了什么骚操作。

按照`(e.hash & 原数组容量oldCap) == 0`规则，将旧链表分成两条新链表。等于0的元素存储在一条链表，不等于0的元素存储在另一条。等于0的那条链表上的元素，在新数组中的索引依然不变。不等于0的那条链表将被放置在新数组的`原数组容量 + 原位置`处。

下面解释一下`e.hash & oldCap`这个表达式的意思。假设现在有一个容量为16的数组，和两个hash值，如下。

| (n-1) & hash          | &运算结果 |
| --------------------- | --------- |
| 0000 1111 & 1101 1001 | 0000 1001 |
| 0000 1111 & 1010 1001 | 0000 1001 |

两个hash映射到同一位置，用一条链表存储。此时数组扩容为32。

| (n-1) & hash                   | &运算结果                         |
| ------------------------------ | --------------------------------- |
| 0001 1111 & 1101 1001（hash1） | 0001 1001 （原数组容量 + 原位置） |
| 0001 1111 & 1010 1001（hash2） | 0000 1001 （原位置）              |

由上面的例子，可以得出一个公式：`新数组的位置 = 原数组容量 + 原位置`。

扩容后，n-1 = 32 - 1= 0001 1111 ，此时参与计算的位数多了一个1。如果hash值对应位置上也是1，则位置需要变化（也就是根据上面的公式变）。而如果hash值对应位置上是0，则计算结果完全没变化，还在原位置。基于上面的思路，JDK中想出了这样的写法，用来区分需要变位置和不需要变位置的节点。

JDK1.8重写了扩容方法resize，取代了1.7中的rehash操作，避免了rehash引起的死循环及低效的问题。这里简单提一句，死循环是在多线程环境下，扩容时，put操作导致了环形链表，但此时并不会发生错误，只是埋下了祸根。一旦调用get方法，获取这条链表上的节点值的时候，就会一直循环下去。系统CPU占用100%。