### 1 HotSpot虚拟机中的垃圾收集器



<img src="images/java/jvm/gc/1.png" width = "50%" />

图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。



#### 1.1 Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器。

- 特点：单线程收集器

- 作用区域：新生代

- 收集算法：复制算法

- 优点：简单、高效（对于其他收集器的单线程）

- 缺点：停顿时间长

- 适合场景：对于限定单个cpu的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在client模式下的虚拟机来说一个很好的选择。
- Serial/Serial Old收集器的运行过程

<img src="images/java/jvm/gc/2.png" />

#### 1.2 ParNew收集器

ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、stw、对象分配原则、回收策略等都与Serial收集器完全一样。

- 特点：多线程收集器

- 作用区域：新生代

- 收集算法：复制算法

- 优点：

- 缺点：

- 适合场景：server端首选的新生代收集器，因为除了Serial收集器，只有ParNew能与CMS收集器配合
- ParNew/Serial Old收集器的运行过程

<img src="images/java/jvm/gc/3.png" />





#### 1.3 Parallel Scavenge收集器

它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓的吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值，即吞吐量 = 运行用户代码时间 ／ （运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

- 特点：并行的多线程收集器

- 作用区域：新生代

- 收集算法：复制算法

- 优点：

- 缺点：

- 适合场景：停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用cpu时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。



Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量

- -XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间，允许值是一个大于0的毫秒值。
- -XX:GCTimeRatio 吞吐量大小，大于0且小于100的整数。





#### 1.4 Serial Old收集器

Serial Old收集器是Serial的老年代版本。

- 特点：单线程收集器

- 作用区域：老年代

- 收集算法：标记-整理算法

- 优点：

- 缺点：

- 适合场景：主要意义是在于给client模式下的虚拟机使用。如果在server模式下，那么它主要还有两大用途，一种是jdk1.5以及之前的版本中与Parallel Scavenge收集器搭配使用。另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。用户的桌面应用场景。
- Serial/Serial Old收集器的运行过程

<img src="images/java/jvm/gc/4.png" />



#### 1.5 Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本。

- 特点：多线程收集器

- 作用区域：老年代

- 收集算法：标记-整理算法

- 优点：

- 缺点：

- 适合场景：注重吞吐量以及cpu资源敏感的场合
- Parallel Scavenge/Parallel Old收集器的工作过程

<img src="images/java/jvm/gc/5.png" />





#### 1.6 CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。

- 作用区域：老年代

- 收集算法：标记-清除算法

- 优点：并发收集、低停顿时间

- 缺点：

- 适用场景：互联网或B/S系统的服务端，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。



整个过程分为4个步骤：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

初始标记、重新标记这两个步骤仍然需要STW。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始化标记阶段稍长一些，但远比并发标记的时间短。



由于整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发只执行的。



CMS收集器的运作步骤中并发和需要停顿的时间。

<img src="images/java/jvm/gc/6.png" />



缺点：

- CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对cpu资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说cpu资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（cpu数量+3）/4，也就是当cpu在4个以上时，并发回收时垃圾收集线程不少于25%的cpu资源，并且随着cpu数量的增加而下降。但是当cpu不足4个（譬如2个）时。CMS对用户程序的影响就可能变得很大，如果本来cpu负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，所做的事情和单cpu年代pc机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替执行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实践证明，增量式的CMS收集器效果很一般，在目前版本中，i-CMS已经被声明为deprecated，即不再提倡用户使用。
- CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉他们，只好留待下一次GC时再清理。这一部分垃圾就被称为浮动垃圾。也是由于在垃圾收集阶段用户线程还需要运行，那也









#### 1.7 G1收集器



### 2 理解GC日志



### 3 垃圾收集器参数总结


- `-XX:UseSerialGC`：`Serial` + `Serial Old`，client模式默认
- `-XX:UseParNewGC`：`ParNew` + `Serial Old`
- `-XX:UseConcMarkSweepGC`：`ParNew` + `CMS` + `Serial Old`
- `-XX:UseParallelGC`：`Parallel Scavenge` + `Serial Old（PS MarkSweep）`
- `-XX:UseParallelOldGC`：`Parallel Scavenge` + `Parallel Old`
- `-XX:UseG1GC`：`G1`



















