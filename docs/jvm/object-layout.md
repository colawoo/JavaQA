
### 1 对象的创建

<img src="_img/jvm/object-layout/hotspot对象创建.jpg" width="75%"/>

a) 当我们`new ArrayList()`的时候，首先虚拟机将去常量池中找，是否有该符号引用，然后判断该符号引用对应的类是否已加载。没有加载的执行加载流程。

b) 对于已加载的类，虚拟机会在堆内存中划分一块确定大小的内存给新对象。
-  对于堆内存的规整与否，分配方式有两种。而Java堆是否规整，又由所采用的垃圾收集器是否带有压缩整理功能来决定。
	- `指针碰撞（Bump the Pointer）`：适用于堆内存规整的情况。在使用Serial、ParNew等带Compact过程的收集器。
	- `空闲列表（Free List）`：适用于堆内存存在碎片的情况。使用CMS这种基于Mark-Sweep算法的收集器。

- 划分内存还需要考虑另外一个问题：并发情况下如何安全划分内存。
	- 对分配内存空间的动作进行同步处理，实际上虚拟机采用`CAS`加上失败重试的方式保证更新操作的原子性。
	- 把内存分配的动作按照线程划分在不同的空间中进行，即每条线程在Java堆中预先分配的一小块内存（称之为本地线程分配缓冲，`Thread Local Allocation Buffer`，`TLAB`）。哪个线程要分配内存，就在哪个线程的`TLAB`上分配，只有`TLAB`用完并分配新的`TLAB`时，才需要同步锁定。可以通过参数`-XX:+/-UseTLAB`来设定虚拟机是否使用TLAB。

c) 内存分配完成后，虚拟机将分配的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。

d) 虚拟机设置对象头信息。

以上，全部工作完成后，从虚拟机角度来看，一个新的对象已经产生了。但从Java程序的视角来看，对象还未创建完成，所有字段都还是零值。

e) 执行`<init>`方法，把对象按照程序员的意愿进行初始化。这样一个真正可用的对象才算完全创建出来。


### 2 对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：`对象头（Header）`、`实例数据（Instance Data）`和`对齐填充（Padding）`。如下图

<img src="_img/jvm/object-layout/hotspot对象内存布局1.jpg" width="75%"/>

#### 2.1 对象头（Header）

##### 2.1.1 Mark Word

用于存储对象自身的运行时数据，如`HashCode`、`GC分代年龄`、`锁状态标识`、`线程持有的锁`、`偏向线程ID`、`偏向时间戳`等。

| 存储内容                           | 标识位(2bit) | 状态     |
| ---------------------------------- | ------------ | -------- |
| HashCode、GC分代年龄               | 01           | 未锁定   |
| 指向锁记录的指针                   | 00           | 轻量级锁 |
| 指向重量级锁的指针                 | 10           | 重量级锁 |
| 空，不需要记录信息                 | 11           | GC标记   |
| 偏向线程ID、偏向时间戳、GC分代年龄 | 01           | 偏向锁   |





##### 2.1.2 类型指针
指向该对象的类元数据的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。

##### 2.1.3 数组长度
如果是一个Java数组，那么对象头还必须有一块用于记录数组长度的数据区域。因为虚拟机可以通过普通Java对象的元数据信息确定对象大小，但从数组的元数据中却无法确定数组大小。
	
#### 2.2 实例数据（Instance Data）

程序代码中定义的各种类型的字段内容。

#### 2.3 对齐填充（Padding）
并不是必然存在的，也没什么特别的含义。仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。


### 3 对象的访问定位

Java程序需要通过栈上的对象引用来操作堆中的对象。Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问堆中的对象。所以对象访问方式取决于虚拟机的具体实现。

目前主流的访问方式有使用`句柄`和`直接指针`两种。`Sun HotSpot`采用的是`直接指针`。

- `句柄`。堆中将会划分出一块内存作为句柄池，引用中存储的就是对象的句柄地址。而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	- 优点：引用中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的对象地址，而引用中存储的值不需要修改。
	

<img src="_img/jvm/object-layout/1.png" width="80%"/>

- `直接指针`。堆中的对象布局就必须考虑如何放置访问类型数据的相关信息，而引用中存储的直接就是对象地址。
	- 优点：速度更快。节省了一次指针定位的时间开销。

<img src="_img/jvm/object-layout/2.png" width="80%"/>










